#!/bin/sh

###############################################################################
# Utility functions
###############################################################################

log() {
  for arg
    do echo "$arg" >&2
  done
}

log_error() {
  log "Error: $2"
  return "$1"
}

require_var() {
  eval "[ -n \"\$$1\" ]" || log_error "$?" "Missing environment variable '$1'"
}

require_command() {
  $(type -t "$1" | grep -q "^.\+$1\$") || log_error "$?" "Missing command '$1'"
}

prepare_env() {
  require_var TVHEADEND_USER     || return "$?"
  require_var TVHEADEND_PASSWORD || return "$?"
  require_var TVHEADEND_HOST     || return "$?"

  TVHEADEND_HTTP_PORT="${TVHEADEND_HTTP_PORT:-9981}"
  TVHEADEND_HTTP_URL="${TVHEADEND_HTTP_URL:-http://$TVHEADEND_HOST:$TVHEADEND_HTTP_PORT}"
  TVHEADEND_HTTP_TIMEOUT="${TVHEADEND_HTTP_TIMEOUT:-15}"

  MQTT_TOPIC_PREFIX="${MQTT_TOPIC_PREFIX:-tvheadend}"

  curl_options=""
  curl_options="$curl_options --get"
  curl_options="$curl_options -s"
  curl_options="$curl_options --max-time $TVHEADEND_HTTP_TIMEOUT"
  curl_options="$curl_options --user $TVHEADEND_USER:$TVHEADEND_PASSWORD"
}

print_json() {
  echo "$1"
}

##
# Run a command and store output in shell variables:
#  $1 holds the name for stdout variable
#  $2 holds the name for stderr variable
#  $3..* hold the command and arguments
##
run() {
  out="$1"; shift
  err="$1"; shift
  command=$*

  # create temp files (type fifo)
  fifo_out=$(mktemp -u) && mkfifo "$fifo_out"
  fifo_err=$(mktemp -u) && mkfifo "$fifo_err"

  # run command and capture output (blocks until read from fifos)
  $command >"$fifo_out" 2>"$fifo_err" &
  pid="$!"

  # open file descriptors and connect to fifos
  exec 3<"$fifo_out" 4<"$fifo_err"

  # store return code
  wait "$pid"
  rc="$?"

  # remove fifos
  rm "$fifo_out" "$fifo_err"

  # read output into variables
  read -r "$out" <&3
  read -r "$err" <&4

  # close file descriptors
  exec 3<&- 4<&-

  return "$rc"
}


###############################################################################
# Request HTTP via cURL
###############################################################################

request() {
  curl $curl_options $* || {
    rc="$?"
    case "$rc" in
      6)  message="Couldn't resolve host" ;;
      7)  message="Failed to connect to host" ;;
      28) message="Timeout after $TVHEADEND_HTTP_TIMEOUT seconds" ;;
      *)  message="cURL returned $?" ;;
    esac
    for url; do : ; done
    log_error "$rc" "$message. URL: $url"
  }
}


###############################################################################
# Request JSON from pre-defined Tvheadend API endpoints
###############################################################################

get_subscriptions() {
  subscriptions=$(request "$TVHEADEND_HTTP_URL/api/status/subscriptions") || return "$?"
  print_json "$subscriptions"
}

get_connections() {
  connections=$(request "$TVHEADEND_HTTP_URL/api/status/connections") || return "$?"
  print_json "$connections"
}

get_upcoming() {
  limit="${1:-5}"
  curl_local_options=""
  curl_local_options="$curl_local_options --data sort=start_real"
  curl_local_options="$curl_local_options --data dir=ASC"
  curl_local_options="$curl_local_options --data limit=$limit"
  upcoming=$(request $curl_local_options "$TVHEADEND_HTTP_URL/api/dvr/entry/grid_upcoming") || return "$?"
  print_json "$upcoming"
}

get_finished() {
  limit="${1:-10}"
  curl_local_options=""
  curl_local_options="$curl_local_options --data sort=start_real"
  curl_local_options="$curl_local_options --data dir=DESC"
  curl_local_options="$curl_local_options --data limit=$limit"
  finished=$(request $curl_local_options "$TVHEADEND_HTTP_URL/api/dvr/entry/grid_finished") || return "$?"
  print_json "$finished"
}

get_storage() {
  storage_info="$1"
  [ -n "$storage_info" ] || log_error "$?" "Missing argument for storage info file" || return "$?"
  [ -s "$storage_info" ] || log_error "$?" "Storage info file '$storage_info' is empty" || return "$?"
  grep -v Filesystem "$storage_info" | (
    while read -r source size used available percent target; do
      mounts="${mounts}${mounts:+, }"$(printf\
        '"%s" : { "size":"%s", "used":"%s", "available":"%s", "percent":"%s", "filesystem":"%s" }\n'\
        "$target" "$size" "$used" "$available" "$percent" "$source"\
      )
    done
    print_json "{ $mounts }"
  )
}

###############################################################################
# Publish and subscribe via MQTT
###############################################################################

publish() {
  log "$(date '+%Y-%m-%d %H:%M:%S') publish $*"

  require_var MQTT_BROKER_HOSTNAME || return "$?"
  require_command mosquitto_pub    || return "$?"

  [ -n "$1" ] || log_error "$?" "Missing argument for 'publish'" || return "$?"
  info="$1"
  shift

  topic="$MQTT_TOPIC_PREFIX/$info"
  command="get_$info"
  if $(type -t "$command" | grep -q "^$command\( is a shell function\)\?\$"); then
    run message error "$command" $* || {
      message="$error"
      topic="$topic/error"
    }
  else
    message="Error: Unsupported Tvheadend info '$info'"
    topic="$topic/error"
    log "$message"
  fi
  [ -n "$message" ] && mosquitto_pub -h "$MQTT_BROKER_HOSTNAME" -t "$topic" -m "$message"
}

subscribe() {
  log "$(date '+%Y-%m-%d %H:%M:%S') subscribe"
  # '$info' must not be quoted so that arguments are handed over separately
  mosquitto_sub -h "$MQTT_BROKER_HOSTNAME" -t "$MQTT_TOPIC_PREFIX/request" | while read -r info; do publish $info; done
}


###############################################################################
# Notify about changes
###############################################################################

notify() {
  log "$(date '+%Y-%m-%d %H:%M:%S') notify $*"

  event="$1"
  directory="$2"
  file="$3"

  case "$file" in
    recording-pre-process)
      publish upcoming
      publish subscriptions
      ;;
    recording-post-process)
      publish finished
      publish upcoming
      publish subscriptions
      publish storage "$directory$file"
      ;;
    recording-post-remove)
      publish storage "$directory$file"
      ;;
    *)
      log "Notification unsupported."
      ;;
  esac
}


###############################################################################
# Prepare environment
###############################################################################

prepare_env || exit "$?"


###############################################################################
# Run arguments
###############################################################################

$*
